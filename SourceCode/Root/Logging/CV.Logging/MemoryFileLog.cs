using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace CV.Logging
{
    /// <summary>
    /// High performance file logging. Uses a persisted memory mapped file to log to disk.
    /// </summary>
    /// <remarks>
    /// <para>
    /// When this class is instantiated, a file of logFileSize will be allocated on the disk. Writing to this file will be 
    /// done by writing to memory. The OS will flush the memory to disk periodically (it happens almost instaneously).
    /// </para>
    /// <para>
    /// The file on disk will have a name of logFileNamePrefix_MM_DD_HH_mm.txt (Month, Day, Hour Minute). If a file with that 
    /// name already exists, a unique name will be generated by appending "_N" where N is a number which makes it unique. 
    /// Once the file has been filled, a new file will be generated by appending "_N" where N is incremented to make the name
    /// unique.
    /// </para>
    /// </remarks>
    public class MemoryFileLog : ILoggingTarget, IDisposable
    {
        private MemoryMappedLogWriter _writer = null;

        private EventPriorities[] _priorities;

        private string _logName;
        private string _logFileDirectory;
        private string _logFileNamePrefix;
        private int _logFileSize;

        /// <summary>
        /// Contructs a new MemoryMapped FileLogging object
        /// </summary>
        /// <param name="logName">Machine unique log name.</param>
        /// <param name="logFileDirectory">Path to serialize the log file</param>
        /// <param name="logFileNamePrefix">Unique prefix for log file name</param>
        /// <param name="logFileSize">Maximun size of log file before rollover</param>
        /// <param name="priorities">Enumeration of EventPriorites</param>
        public MemoryFileLog(string logName, string logFileNamePrefix, string logFileDirectory, int logFileSize, 
                params EventPriorities[] priorities)
        {
            _logName = logName;
            _logFileNamePrefix = logFileNamePrefix;
            _logFileDirectory = logFileDirectory;
            _logFileSize = logFileSize;
            _writer = new MemoryMappedLogWriter(_logName + Guid.NewGuid()
                    , GenerateLogFileName()
                    , "txt"
                    , _logFileDirectory
                    , false
                    , _logFileSize);
            _priorities = priorities;
        }

        /// <summary>
        /// Writes the given message to the memory mapped file.
        /// </summary>
        /// <param name="message">String to write</param>
        /// <param name="appendText">always true</param>
        /// <param name="eventReference">null; not used</param>
        /// <param name="entryType">Not used</param>
        /// <param name="enumPriority">Not used</param>
        public void Write(string message
                , bool appendText = true
                , long? eventReference = null
                , System.Diagnostics.EventLogEntryType entryType = System.Diagnostics.EventLogEntryType.Information
                , EventPriorities Priority = EventPriorities.All)
        {
            _writer.Write(message + Environment.NewLine);
        }

        /// <summary>
        /// Returns the enumerable collection of priorities
        /// </summary>
        public IEnumerable<EventPriorities> Priorities
        {
            get { return _priorities; }
        }

        /// <summary>
        /// Generates a unique log file name
        /// </summary>
        /// <returns>Unique file name string</returns>       
        private string GenerateLogFileName()
        {
            DateTime now = DateTime.Now;
            return string.Format("{0}_{1}_{2:##}{3:##}{4}{5}", _logFileNamePrefix,
                    System.Diagnostics.Process.GetCurrentProcess().Id, now.Month, now.Day, now.ToString("HH"),
                    now.ToString("MM"));
        }

        /// <summary>
        /// Disposes the InMemory FileLogger's resources
        /// </summary>
        public void Dispose()
        {
            if(_writer != null)
            {
                _writer.Dispose();
            }
        }

        /// <summary>
        /// Destructor for InMemory FileLog
        /// </summary>
        ~MemoryFileLog()
        {
            Dispose();
        }
    }
}
