using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data;

using CV.Cache;

namespace CV.Database
{
    /// <summary>
    /// Contains the data attributes for a database table column 
    /// as found in the database's catalog.  It also contains
    /// a cross reference of DataTypes (between back-end specific
    /// and .Net and DataAccessApplicationBloock types)
    /// </summary>
    public struct DbColumn
    {
        /// <summary>
        /// Name of column
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Schema of the table that the column belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the column belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema + TableName that the column belongs to
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ColumnName; } }
        /// <summary>
        /// The .Net framework dataType of the column
        /// </summary>
        public string DataTypeDotNet;
        /// <summary>
        /// The back-end database specific dataType of the column
        /// </summary>
        public string DataTypeNativeDb;
        /// <summary>
        /// DataColumn (of a DataTable) dataType of the column
        /// </summary>
        public string DataTypeDataColumn;
        /// <summary>
        /// DataAccess Application Block dataType of the column
        /// </summary>
        public DbType DataTypeGenericDb;
        /// <summary>
        /// Indicates if null is allowed for column value
        /// </summary>
        public bool IsNullable;
        /// <summary>
        /// Indicates if it is a computed column (SqlServer specific)
        /// </summary>
        public bool IsComputed;
        /// <summary>
        /// Indicates if the column has an autogenerated value (e.g. DateTime, Identity (SqlServer))
        /// </summary>
        public bool IsAutoGenerated;
        /// <summary>
        /// Indicates if the column has a database default value
        /// </summary>
        public bool HasDefault;
        /// <summary>
        /// The position that the column is within the table
        /// </summary>
        public Int16 Ordinal;
        /// <summary>
        /// Used to set the maximum length of character columns
        /// </summary>
        public Int32 MaxLength;
        /// <summary>
        /// Number of digits to left of decimal (radix) point
        /// </summary>
        public Int16 Precision;
        /// <summary>
        /// decimal point
        /// </summary>
        public Int16 Radix;
        /// <summary>
        /// Number of digits to the right of the decimal (radix) point
        /// </summary>
        public Int16 Scale;
        /// <summary>
        /// Value of the column
        /// </summary>
        public object Value;
    }

    /// <summary>
    /// Contains the meta data regarding table indexes
    /// </summary>
    public struct DbIndex
    {
        /// <summary>
        /// Name of the index
        /// </summary>
        public string IndexName;
        /// <summary>
        /// Schema of the table that the index belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the index belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.IndexName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + IndexName; } }
        /// <summary>
        /// Indicates if the index is a unqique index
        /// </summary>
        public bool IsUnique;
        /// <summary>
        /// Indicates if the index is the primary key
        /// </summary>
        public bool IsPrimaryKey;
        /// <summary>
        /// Indicates if the index is a clustered index
        /// </summary>
        public bool IsClustered;
        /// <summary>
        /// The ordered list of columns defining the index
        /// </summary>
        public SortedDictionary<Int16, DbIndexColumn> ColumnOrder;
        /// <summary>
        /// Collection of index columns
        /// </summary>
        public CacheMgr<string, DbIndexColumn> Columns;
        /// <summary>
        /// A list of columns to be included with Index but not part of key directly(SQLServer 2008 >)
        /// </summary>
        public List<string> IncludeColumns;
        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbIndex">DbIndexStructure to copy</param>
        public DbIndex(DbIndex dbIndex)
        {
            IndexName = dbIndex.IndexName;
            SchemaName = dbIndex.SchemaName;
            TableName = dbIndex.TableName;
            IsUnique = dbIndex.IsUnique;
            IsPrimaryKey = dbIndex.IsPrimaryKey;
            IsClustered = dbIndex.IsClustered;
            ColumnOrder = new SortedDictionary<short, DbIndexColumn>(dbIndex.ColumnOrder);
            Columns = dbIndex.Columns.Copy(dbIndex.Columns);
            IncludeColumns = new List<string>(dbIndex.IncludeColumns);
        }
    }


    /// <summary>
    /// Contains the meta data regarding table foreign keys
    /// </summary>
    public struct DbForeignKey
    {
        /// <summary>
        /// Name of the Constraint
        /// </summary>
        public string ForeignKeyName;
        /// <summary>
        /// The schema of the referenced table
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// The name of the referenced table
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.ForeignKeyName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ForeignKeyName; } }
        /// <summary>
        /// The ordered list of columns defining the constraint
        /// where the key is the ordinal within the key and the value is the columnName
        /// </summary>
        public SortedDictionary<Int16, string> KeyOrder;
        /// <summary>
        /// The collection of base column to referenced column relationships
        /// </summary>
        public Dictionary<string, string> KeyColumns;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbForeignKey">DbForeignKeyStructure to copy</param>
        public DbForeignKey(DbForeignKey dbForeignKey)
        {
            ForeignKeyName = dbForeignKey.ForeignKeyName;
            SchemaName = dbForeignKey.SchemaName;
            TableName = dbForeignKey.TableName;
            KeyOrder = new SortedDictionary<short, string>(dbForeignKey.KeyOrder);
            KeyColumns = new Dictionary<string, string>(dbForeignKey.KeyColumns, StringComparer.CurrentCultureIgnoreCase);
        }
    }


    /// <summary>
    /// Represents a fully qualified database object
    /// </summary>
    /// <typeparam name="T">Type of Database Object (e.g. Column, Table, etc)</typeparam>
#pragma warning disable 1591 // disable the xmlComments warning
    public class DbQualifiedObject<T>
    {
        string _alias = null;
        public string Alias { get { return _alias; } }
        public string SchemaName { get; set; }
        public string TableName { get; set; }
        public T DbObject { get; set; }

        public DbQualifiedObject(string schemaName, string tableName, T dbObject)
            : this(schemaName, tableName, null, dbObject)
        {
        }

        public DbQualifiedObject(string schemaName, string tableName, string alias, T dbObject)
        {
            SchemaName = schemaName;
            TableName = tableName;
            DbObject = dbObject;
            _alias = !string.IsNullOrEmpty(alias) ? alias : null;
        }

        public override int GetHashCode()
        {
            return ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return this == (DbQualifiedObject<T>)obj;
        }

        public override string ToString()
        {
            return String.Format("{0}.{1}", !string.IsNullOrEmpty(_alias) ? _alias
                : SchemaName + "." + TableName, DbObject.ToString());
        }

        public static bool operator ==(DbQualifiedObject<T> l, DbQualifiedObject<T> r)
        {
            return r.ToString().ToLower() == l.ToString().ToLower();
        }

        public static bool operator !=(DbQualifiedObject<T> l, DbQualifiedObject<T> r)
        {
            return !(r == l);
        }
    }
#pragma warning restore 1591 // disable the xmlComments warning

    /// <summary>
    /// Contains the meta data regarding tables
    /// </summary>
    public struct DbTable
    {
        /// <summary>
        /// Name of the table
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema name
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// SchemaName + "." + TableName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName; } }
        /// <summary>
        /// An ordered list of the columns that belong to the table
        /// where the Key is the Ordinal and the Value is the ColumnName
        /// </summary>
        public SortedDictionary<short, string> Row;
        /// <summary>
        /// A collection of the table's columns
        /// where the key is the ColumnName and the Value is the Ordinal
        /// </summary>
        public Dictionary<string, short> Columns;
        /// <summary>
        /// A collection of the primary key columns (not ordered)
        /// Where the key is the ColumnName and the Value is the position within the index
        /// </summary>
        public Dictionary<string, byte> PrimaryKeyColumns;
        /// <summary>
        /// An ordered list of the primary key columns
        /// where the key is the position with the index and the value is the ColumnName
        /// </summary>
        public SortedDictionary<byte, string> PrimaryKey;
        /// <summary>
        /// An ordered list of the indexes(and their columns) on the table
        /// where the key is the index name and the value contains the index meta data
        /// </summary>
        public Dictionary<string, DbIndex> Indexes;
        /// <summary>
        /// The collection of foreign keys on the table (if any)
        /// Where the key is the name of the key and the value contains the key meta data
        /// </summary>
        public Dictionary<string, DbForeignKey> ForeignKeys;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbTable">DbTableStructure to copy</param>
        public DbTable(DbTable dbTable)
        {
            TableName = dbTable.TableName;
            SchemaName = dbTable.SchemaName;
            Row = new SortedDictionary<short, string>(dbTable.Row);
            Columns = new Dictionary<string, short>(dbTable.Columns, StringComparer.CurrentCultureIgnoreCase);
            PrimaryKeyColumns = new Dictionary<string, byte>(dbTable.PrimaryKeyColumns, StringComparer.CurrentCultureIgnoreCase);
            PrimaryKey = new SortedDictionary<byte, string>(dbTable.PrimaryKey);
            Indexes = dbTable.Indexes.ToDictionary(kvp => kvp.Key, kvp => new DbIndex(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase);
            ForeignKeys = dbTable.ForeignKeys.ToDictionary(kvp => kvp.Key, kvp => new DbForeignKey(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase);
        }
    }

    /// <summary>
    /// Enumerations of comparison operators used in where clauses or joins
    /// </summary>
#pragma warning disable 1591 // disable the xmlComments warning
    public enum ComparisonOperators { Equals, Greater, Less, GreaterEquals, LessEquals, NotEquals, Between, NotBetween, In, NotIn }
#pragma warning restore 1591 // restore the xmlComments warning

    /// <summary>
    /// Contains meta data about comparison operations to be used in dynamic sql
    /// in where clauses (e.g. in or >=, etc) or joins
    /// </summary>
    public struct DbComparisonOperator
    {
        /// <summary>
        /// Comparison operation enumerator (e.g. Equals, Greater, LessThan, etc)
        /// </summary>
        public ComparisonOperators ComparisonOperator;
        /// <summary>
        /// Returns the SQL compliant string representation of the enumerations
        /// </summary>
        public string OperatorString
        {
            get
            {
                switch (ComparisonOperator)
                {
                    case ComparisonOperators.In:
                        return "in";
                    case ComparisonOperators.NotIn:
                        return "not in";
                    case ComparisonOperators.Between:
                        return "between";
                    case ComparisonOperators.NotBetween:
                        return "not between";
                    case ComparisonOperators.Less:
                        return "<";
                    case ComparisonOperators.LessEquals:
                        return "<=";
                    case ComparisonOperators.Greater:
                        return ">";
                    case ComparisonOperators.GreaterEquals:
                        return ">=";
                    case ComparisonOperators.NotEquals:
                        return "<>";
                    default:
                        return "=";
                };
            }
        }
        /// <summary>
        /// Ordered set of operator values which can be a set of bind variables or constants
        /// for example as used in an IN clause
        /// </summary>
        public List<DbBindVariable> OperatorValues;
        /// <summary>
        /// If true will cause a SQL compliant check for null in the comparison 
        /// </summary>
        public bool IncludeNullCheck;
    }

    /// <summary>
    /// Metadata about columns used in indexes. 
    /// </summary>
    public struct DbIndexColumn
    {
        /// <summary>
        /// The column's name
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Used for functional based indexes
        /// </summary>
        public string ColumnFunction;
        /// <summary>
        /// Indicates if the column is sorted descending
        /// </summary>
        public bool IsDescending;
    }

    /// <summary>
    /// Metadata about a bind value to be used in dynamic sql to set a column
    /// </summary>
    public struct DbBindVariable
    {
        /// <summary>
        /// Contains the string used by the application programmer to refer
        /// to a particular value;  A parameter will be created for that
        /// variable only if the Column is provided for type definition.
        /// Otherwise, the programmer will need to define a parameter
        /// after the DbCommand is created.
        /// </summary>
        public string VariableOrConst;
        /// <summary>
        /// The optional column name if a bind variable is associated with
        /// a column, then it's type can be derived automatically.
        /// </summary>
        public string BindToColumnType;
    }

    /// <summary>
    /// Contains meta data for generating back-end specific function calls
    /// in dynamic sql.
    /// </summary>
    public struct DbFunctionStructure
    {
        /// <summary>
        /// Indicates that the column has an autogenerated value and
        /// nothing needs to be set.
        /// </summary>
        public bool AutoGenerate;
        /// <summary>
        /// Provides the back-end specific function syntax to be used
        /// to set the value of a column.
        /// </summary>
        public string FunctionBody;
    }

    public class Constants
    {
        public const string ConnectionKey = "ConnectionKey";

        public const string SCHEMA_CORE = "CV";
        internal const string TABLE_UNIQUEIDS = "UniqueIds";
        internal const string USP_UniqueIdsGetNextRange = "cv.usp_UniqueIdsGetNextRange";
        internal const string RangeAmount = "RangeAmount";
        internal const string ReturnTable = "ReturnTable";

        internal const string All_Constraints = "All_Constraints";
        internal const string All_Cons_Columns = "All_Cons_Columns";
        internal const string All_Ind_Columns = "All_Ind_Columns";
        internal const string All_Ind_Expressions = "All_Ind_Expressions";
        internal const string All_Indexes = "All_Indexes";
        internal const string All_Tab_Columns = "All_Tab_Columns";

        internal const string CatalogGetPrimaryKeys = "CatalogGetPrimaryKeys";
        internal const string CatalogGetIndexes = "CatalogGetIndexes";
        internal const string CatalogGetForeignKeys = "CatalogGetFkeys";
        internal const string CatalogGetColumns = "CatalogGetColumns";
        internal const string Char_Length = "char_length";
        internal const string Character_Mximum_Length = "character_maximum_length";
        internal const string CharacterMaximumLength = "CharacterMaximumLength";
        internal const string ColumnFunction = "ColumnFunction";
        internal const string ColId = "ColId";
        internal const string ColName = "ColName";
        internal const string ColOrder = "ColOrder";
        internal const string ColSeq = "ColSeq";
        internal const string Column_Expression = "Column_Expression";
        internal const string Column_Name = "Column_Name";
        internal const string Column_Position = "Column_Position";
        internal const string ColumnName = "ColumnName";
        internal const string Column_Default = "Column_Default";
        internal const string ColumnDefault = "ColumnDefault";
        internal const string Column_Id = "Column_Id";
        internal const string Columns = "Columns";
        internal const string ConstraintName = "ConstraintName";
        internal const string Constraint_Catalog = "Constraint_Catalog";
        internal const string Constraint_Name = "Constraint_Name";
        internal const string Constraint_Object_Id = "Constraint_Object_Id";
        internal const string Constraint_Schema = "Constraint_Schema";
        internal const string Constraint_Type = "Constraint_Type";
        internal const string Data_Type = "Data_Type";
        internal const string Data_Default = "Data_Default";
        internal const string Data_Length = "Data_Length";
        internal const string Data_Precision = "Data_Precision";
        internal const string Data_Scale = "Data_Scale";
        internal const string DataType = "DataType";
        internal const string DataTime_Precision = "DateTime_Precision";
        internal const string DataTimePrecision = "DateTimePrecision";
        internal const string DbProviderFactoryDB2 = "IBM.Data.DB2.DB2Factory";
        internal const string DbProviderFactoryOracle = "Oracle.DataAccess.Client.OracleClientFactory";
        internal const string Descend = "Descend";
        internal const string FKColumn_Name = "FKColumn_Name";
        internal const string FKTable_Schem = "FKTable_Schem";
        internal const string FKTable_Name = "FKTable_Name";
        internal const string FK_Name = "FK_Name";
        internal const string ForeignKey = "ForeignKey";
        internal const string ForeignKeyName = "ForeignKeyName";
        internal const string ForeignKeys = "ForeignKeys";
        internal const string Foreign_Key_Columns = "Foreign_Key_Columns";
        internal const string Foreign_Keys = "Foreign_Keys";

        internal const string Id = "Id";
        internal const string IndSchema = "IndSchema";
        internal const string Index_Name = "Index_Name";
        internal const string Index_Owner = "Index_Owner";
        internal const string IndexName = "IndexName";
        internal const string IndName = "IndName";
        internal const string Index_Columns = "Index_Columns";
        internal const string Index_Id = "Index_Id";
        internal const string Indexes = "Indexes";
        internal const string IndexColUse = "IndexColUse";
        internal const string IndexType = "IndexType";
        internal const string Information_Schema = "Information_Schema";
        internal const string Is_Computed = "Is_Computed";
        internal const string Is_Descending_Key = "Is_Descending_Key";
        internal const string IsComputed = "IsComputed";
        internal const string IsDescend = "IsDescend";
        internal const string Is_Identity = "Is_Identity";
        internal const string IsIdentity = "IsIdentity";
        internal const string Is_Nullable = "Is_Nullable";
        internal const string IsNullable = "IsNullable";
        internal const string IsPrimaryKey = "IsPrimaryKey";
        internal const string IsRowGuidCol = "IsRowGuidCol";
        internal const string Is_RowGuidCol = "Is_RowGuidCol";
        internal const string Key_Column_Usage = "Key_Column_Usage";
        internal const string Key_Ordinal = "Key_Ordinal";
        internal const string KeyColUse = "KeyColUse";
        internal const string Key_Seq = "Key_Seq";
        internal const string Is_Primary_Key = "Is_Primary_Key";
        internal const string Is_Unique = "Is_Unique";
        internal const string IsUnique = "IsUnique";
        internal const string IsClustered = "IsClustered";
        internal const string MaxIdValue = "MaxIdValue";
        internal const string Name = "name";
        internal const string Numeric_Precision = "Numeric_Precision";
        internal const string NumericPrecision = "NumericPrecision";
        internal const string Numeric_Precision_Radix = "Numeric_Precision_Radix";
        internal const string NumericPrecisionRadix = "NumericPrecisionRadix";
        internal const string Numeric_Scale = "Numeric_Scale";
        internal const string NumericScale = "NumericScale";
        internal const string Nullable = "Nullable";
        internal const string Objects = "Objects";
        internal const string Object_Id = "Object_Id";
        internal const string Ordinal = "Ordinal";
        internal const string Ordinal_Position = "Ordinal_Position";
        internal const string OrdinalPosition = "OrdinalPosition";
        internal const string Owner = "Owner";
        /// <summary>
        /// Default Parameter Name for Paging 'Page Size'
        /// </summary>
        public const string PageSize = "PageSize";
        internal const string ParamNewId = "NewId";
        internal const string ParamDelimiters = ", {0}()[];+-/*.<>=!";
        internal const string Parent_Column_Id = "Parent_Column_Id";
        internal const string Parent_Object_Id = "Parent_Object_Id";
        internal const string Position = "Position";
        internal const string PKColumn_Name = "PKColumn_Name";
        internal const string PKTable_Schem = "PKTable_Schem";
        internal const string PKTable_Name = "PKTable_Name";
        internal const string PK_Name = "PK_Name";
        internal const string PrimaryKeyName = "PrimaryKeyName";
        internal const string PrimaryKey = "PrimaryKey";
        internal const string PrimaryKeys = "PrimaryKeys";
        internal const string Pseudo_Column = "pseudo_column";
        internal const string R_Constraint_Name = "R_Constraint_Name";
        internal const string R_Owner = "R_Owner";
        internal const string RefSchema = "RefSchema";
        internal const string RefTable = "RefTable";
        internal const string RefColumn = "RefColumn";
        internal const string Referenced_Column_Id = "Referenced_Column_Id";
        internal const string Referenced_Object_Id = "Referenced_Object_Id";
        internal const string Return_Value = "Return_Value";
        internal const string RolloverIdValue = "RolloverIdValue";
        internal const string Schema_Id = "Schema_Id";
        internal const string SchemaName = "SchemaName";
        internal const string Schemas = "Schemas";
        internal const string SQLColumns = "SQLColumns";
        internal const string SQLForeignKeys = "SQLForeignKeys";
        internal const string SQLPrimaryKeys = "SQLPrimaryKeys";
        internal const string Sys = "sys";
        internal const string SysCat = "syscat";
        internal const string SysColumns = "SysColumns";
        internal const string SysIbm = "sysibm";
        internal const string TabName = "TabName";
        internal const string Table_Constraints = "Table_Constraints";
        internal const string Table_Name = "Table_Name";
        internal const string Table_Schem = "Table_Schem";
        internal const string Table_Schema = "Table_Schema";
        internal const string TableName = "TableName";
        internal const string Tables = "Tables";
        internal const string Type = "Type";
        internal const string Type_Desc = "Type_Desc";
        internal const string TypeDescription = "TypeDescription";
        internal const string Type_Name = "Type_Name";
        internal const string UniqueIdValue = "UniqueIdValue";
        internal const string UniqueIdKey = "UniqueIdKey";
        internal const string UniqueRule = "UniqueRule";
        internal const string Uniqueness = "Uniqueness";

        internal const string ParamSetValueSuffix = "_sv";
        internal const byte ParamNameOracleMaxLength = 30; // maximum size of a parameter name required for Oracle
        internal const string ParamAliasSuffix = "_a";

        // The maximum size, in bytes, of the data within the column. The default value is 0 
        // (to be used when you do not want to specify the maximum size of the value).
        internal const Int32 ParamSizeDefault = 0;

    }
}
