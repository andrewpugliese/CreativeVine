using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Data;
using System.Data.Common;

using CV.Cache;
using CV.Global;

namespace CV.Database
{
    /// <summary>
    /// Contains the data attributes for a database table column 
    /// as found in the database's catalog.  It also contains
    /// a cross reference of DataTypes (between back-end specific
    /// and .Net and DataAccessApplicationBloock types)
    /// </summary>
    public struct DbColumn
    {
        /// <summary>
        /// Name of column
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Schema of the table that the column belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the column belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema + TableName that the column belongs to
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ColumnName; } }
        /// <summary>
        /// The .Net framework dataType of the column
        /// </summary>
        public string DataTypeDotNet;
        /// <summary>
        /// The back-end database specific dataType of the column
        /// </summary>
        public string DataTypeNativeDb;
        /// <summary>
        /// DataColumn (of a DataTable) dataType of the column
        /// </summary>
        public string DataTypeDataColumn;
        /// <summary>
        /// DataAccess Application Block dataType of the column
        /// </summary>
        public DbType DataTypeGenericDb;
        /// <summary>
        /// Indicates if null is allowed for column value
        /// </summary>
        public bool IsNullable;
        /// <summary>
        /// Indicates if it is a computed column (SqlServer specific)
        /// </summary>
        public bool IsComputed;
        /// <summary>
        /// Indicates if the column has an autogenerated value (e.g. DateTime, Identity (SqlServer))
        /// </summary>
        public bool IsAutoGenerated;
        /// <summary>
        /// Indicates if the column has a database default value
        /// </summary>
        public bool HasDefault;
        /// <summary>
        /// The position that the column is within the table
        /// </summary>
        public Int16 Ordinal;
        /// <summary>
        /// Used to set the maximum length of character columns
        /// </summary>
        public Int32 MaxLength;
        /// <summary>
        /// Number of digits to left of decimal (radix) point
        /// </summary>
        public Int16 Precision;
        /// <summary>
        /// decimal point
        /// </summary>
        public Int16 Radix;
        /// <summary>
        /// Number of digits to the right of the decimal (radix) point
        /// </summary>
        public Int16 Scale;
        /// <summary>
        /// Value of the column
        /// </summary>
        public object Value;
    }

    /// <summary>
    /// Contains the meta data regarding table indexes
    /// </summary>
    public struct DbIndex
    {
        /// <summary>
        /// Name of the index
        /// </summary>
        public string IndexName;
        /// <summary>
        /// Schema of the table that the index belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the index belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.IndexName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + IndexName; } }
        /// <summary>
        /// Indicates if the index is a unqique index
        /// </summary>
        public bool IsUnique;
        /// <summary>
        /// Indicates if the index is the primary key
        /// </summary>
        public bool IsPrimaryKey;
        /// <summary>
        /// The ordered list of columns defining the index
        /// </summary>
        public SortedDictionary<Int16, DbIndexColumn> Columns;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbIndex">DbIndexStructure to copy</param>
        public DbIndex(DbIndex dbIndex)
        {
            IndexName = dbIndex.IndexName;
            SchemaName = dbIndex.SchemaName;
            TableName = dbIndex.TableName;
            IsUnique = dbIndex.IsUnique;
            IsPrimaryKey = dbIndex.IsPrimaryKey;
            Columns = new SortedDictionary<short, DbIndexColumn>(dbIndex.Columns);
        }
    }


    /// <summary>
    /// Contains the meta data regarding table foreign keys
    /// </summary>
    public struct DbForeignKey
    {
        /// <summary>
        /// Name of the Constraint
        /// </summary>
        public string ForeignKeyName;
        /// <summary>
        /// The schema of the referenced table
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// The name of the referenced table
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.ForeignKeyName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ForeignKeyName; } }
        /// <summary>
        /// The ordered list of columns defining the constraint
        /// where the key is the ordinal within the key and the value is the columnName
        /// </summary>
        public SortedDictionary<Int16, string> KeyOrder;
        /// <summary>
        /// The collection of base column to referenced column relationships
        /// </summary>
        public Dictionary<string, string> KeyColumns;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbForeignKey">DbForeignKeyStructure to copy</param>
        public DbForeignKey(DbForeignKey dbForeignKey)
        {
            ForeignKeyName = dbForeignKey.ForeignKeyName;
            SchemaName = dbForeignKey.SchemaName;
            TableName = dbForeignKey.TableName;
            KeyOrder = new SortedDictionary<short, string>(dbForeignKey.KeyOrder);
            KeyColumns = new Dictionary<string, string>(dbForeignKey.KeyColumns, StringComparer.CurrentCultureIgnoreCase);
        }
    }


    /// <summary>
    /// Represents a fully qualified database object
    /// </summary>
    /// <typeparam name="T">Type of Database Object (e.g. Column, Table, etc)</typeparam>
#pragma warning disable 1591 // disable the xmlComments warning
    public class DbQualifiedObject<T>
    {
        string _alias = null;
        public string Alias { get { return _alias; } }
        public string SchemaName { get; set; }
        public string TableName { get; set; }
        public T DbObject { get; set; }

        public DbQualifiedObject(string schemaName, string tableName, T dbObject)
            : this(schemaName, tableName, null, dbObject)
        {
        }

        public DbQualifiedObject(string schemaName, string tableName, string alias, T dbObject)
        {
            SchemaName = schemaName;
            TableName = tableName;
            DbObject = dbObject;
            _alias = !string.IsNullOrEmpty(alias) ? alias : null;
        }

        public override int GetHashCode()
        {
            return ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return this == (DbQualifiedObject<T>)obj;
        }

        public override string ToString()
        {
            return String.Format("{0}.{1}", !string.IsNullOrEmpty(_alias) ? _alias
                : SchemaName + "." + TableName, DbObject.ToString());
        }

        public static bool operator ==(DbQualifiedObject<T> l, DbQualifiedObject<T> r)
        {
            return r.ToString().ToLower() == l.ToString().ToLower();
        }

        public static bool operator !=(DbQualifiedObject<T> l, DbQualifiedObject<T> r)
        {
            return !(r == l);
        }
    }
#pragma warning restore 1591 // disable the xmlComments warning

    /// <summary>
    /// Contains the meta data regarding tables
    /// </summary>
    public struct DbTable
    {
        /// <summary>
        /// Name of the table
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema name
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// SchemaName + "." + TableName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName; } }
        /// <summary>
        /// An ordered list of the columns that belong to the table
        /// where the Key is the Ordinal and the Value is the ColumnName
        /// </summary>
        public SortedDictionary<short, string> Row;
        /// <summary>
        /// A collection of the table's columns
        /// where the key is the ColumnName and the Value is the Ordinal
        /// </summary>
        public Dictionary<string, short> Columns;
        /// <summary>
        /// A collection of the primary key columns (not ordered)
        /// Where the key is the ColumnName and the Value is the position within the index
        /// </summary>
        public Dictionary<string, byte> PrimaryKeyColumns;
        /// <summary>
        /// An ordered list of the primary key columns
        /// where the key is the position with the index and the value is the ColumnName
        /// </summary>
        public SortedDictionary<byte, string> PrimaryKey;
        /// <summary>
        /// An ordered list of the indexes(and their columns) on the table
        /// where the key is the index name and the value contains the index meta data
        /// </summary>
        public Dictionary<string, DbIndex> Indexes;
        /// <summary>
        /// The collection of foreign keys on the table (if any)
        /// Where the key is the name of the key and the value contains the key meta data
        /// </summary>
        public Dictionary<string, DbForeignKey> ForeignKeys;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbTable">DbTableStructure to copy</param>
        public DbTable(DbTable dbTable)
        {
            TableName = dbTable.TableName;
            SchemaName = dbTable.SchemaName;
            Row = new SortedDictionary<short, string>(dbTable.Row);
            Columns = new Dictionary<string, short>(dbTable.Columns, StringComparer.CurrentCultureIgnoreCase);
            PrimaryKeyColumns = new Dictionary<string, byte>(dbTable.PrimaryKeyColumns, StringComparer.CurrentCultureIgnoreCase);
            PrimaryKey = new SortedDictionary<byte, string>(dbTable.PrimaryKey);
            Indexes = dbTable.Indexes.ToDictionary(kvp => kvp.Key, kvp => new DbIndex(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase);
            ForeignKeys = dbTable.ForeignKeys.ToDictionary(kvp => kvp.Key, kvp => new DbForeignKey(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase);
        }
    }

    /// <summary>
    /// Enumerations of comparison operators used in where clauses or joins
    /// </summary>
#pragma warning disable 1591 // disable the xmlComments warning
    public enum ComparisonOperators { Equals, Greater, Less, GreaterEquals, LessEquals, NotEquals, Between, NotBetween, In, NotIn }
#pragma warning restore 1591 // restore the xmlComments warning

    /// <summary>
    /// Contains meta data about comparison operations to be used in dynamic sql
    /// in where clauses (e.g. in or >=, etc) or joins
    /// </summary>
    public struct DbComparisonOperator
    {
        /// <summary>
        /// Comparison operation enumerator (e.g. Equals, Greater, LessThan, etc)
        /// </summary>
        public ComparisonOperators ComparisonOperator;
        /// <summary>
        /// Returns the SQL compliant string representation of the enumerations
        /// </summary>
        public string OperatorString
        {
            get
            {
                switch (ComparisonOperator)
                {
                    case ComparisonOperators.In:
                        return "in";
                    case ComparisonOperators.NotIn:
                        return "not in";
                    case ComparisonOperators.Between:
                        return "between";
                    case ComparisonOperators.NotBetween:
                        return "not between";
                    case ComparisonOperators.Less:
                        return "<";
                    case ComparisonOperators.LessEquals:
                        return "<=";
                    case ComparisonOperators.Greater:
                        return ">";
                    case ComparisonOperators.GreaterEquals:
                        return ">=";
                    case ComparisonOperators.NotEquals:
                        return "<>";
                    default:
                        return "=";
                };
            }
        }
        /// <summary>
        /// Ordered set of operator values which can be a set of bind variables or constants
        /// for example as used in an IN clause
        /// </summary>
        public List<DbBindVariable> OperatorValues;
        /// <summary>
        /// If true will cause a SQL compliant check for null in the comparison 
        /// </summary>
        public bool IncludeNullCheck;
    }

    /// <summary>
    /// Metadata about columns used in indexes. 
    /// </summary>
    public struct DbIndexColumn
    {
        /// <summary>
        /// The column's name
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Used for functional based indexes
        /// </summary>
        public string ColumnFunction;
        /// <summary>
        /// Indicates if the column is sorted descending
        /// </summary>
        public bool IsDescending;
    }

    /// <summary>
    /// Metadata about a bind value to be used in dynamic sql to set a column
    /// </summary>
    public struct DbBindVariable
    {
        /// <summary>
        /// Contains the string used by the application programmer to refer
        /// to a particular value;  A parameter will be created for that
        /// variable only if the Column is provided for type definition.
        /// Otherwise, the programmer will need to define a parameter
        /// after the DbCommand is created.
        /// </summary>
        public string VariableOrConst;
        /// <summary>
        /// The optional column name if a bind variable is associated with
        /// a column, then it's type can be derived automatically.
        /// </summary>
        public string BindToColumnType;
    }

    /// <summary>
    /// Contains meta data for generating back-end specific function calls
    /// in dynamic sql.
    /// </summary>
    public struct DbFunctionStructure
    {
        /// <summary>
        /// Indicates that the column has an autogenerated value and
        /// nothing needs to be set.
        /// </summary>
        public bool AutoGenerate;
        /// <summary>
        /// Provides the back-end specific function syntax to be used
        /// to set the value of a column.
        /// </summary>
        public string FunctionBody;
    }

    /// <summary>
    /// Maintains a cache of database catalog information about tables
    /// which can be used for generating dynamic sql.
    /// </summary>
    internal class DbCatalogMgr
    {
        private DatabaseMgr _dbMgr = null;
        CacheMgr<string, DbColumn> _columnCache = new CacheMgr<string, DbColumn>(StringComparer.CurrentCultureIgnoreCase);
        CacheMgr<string, DbTable> _tableCache = new CacheMgr<string, DbTable>(StringComparer.CurrentCultureIgnoreCase);
        CacheMgr<string, DbCommand> _dbCmdCache = new CacheMgr<string, DbCommand>(StringComparer.CurrentCultureIgnoreCase);

        enum TableAttributes
        {
            SchemaName, SchemaId, TableName, TableId, Hierarchy, ReconciledDate,
            Description
        };

        enum ColumnAttributes
        {
            SchemaName, TableName, TableId, ColumnId, ColumnName, DataType, ReconciledDate,
            Description, OrdinalPosition, ColumnDefault, IsNullable, IsIdentity,
            IsComputed, CharacterMaximumLength, NumericPrecision, NumericPrecisionRadix,
            NumericScale, DateTimePrecision
        };

        /// <summary>
        /// Database Catalog Cache of Database Objects (Tables, Columns, PrimaryKeys)
        /// Cache will the lazily initialized as requests for objects are made
        /// </summary>
        /// <param name="dbMgr"></param>
        internal DbCatalogMgr(DatabaseMgr dbMgr)
        {
            _dbMgr = dbMgr;
            // Build the DbCommandCache
            LoadDbCommandCache();
        }

        internal void ClearCache()
        {
            _columnCache.Clear();
            _tableCache.Clear();
        }

        /// <summary>
        /// Build the dbCommands and add them to the cache.
        /// </summary>
        void LoadDbCommandCache()
        {
            DbCommand dbCmd = GetCatalogColumnsCmd();
            _dbCmdCache.Add(Constants.CatalogGetColumns, dbCmd);

            dbCmd = GetCatalogPrimaryKeysCmd();
            _dbCmdCache.Add(Constants.CatalogGetPrimaryKeys, dbCmd);

            dbCmd = GetCatalogIndexesCmd();
            _dbCmdCache.Add(Constants.CatalogGetIndexes, dbCmd);

            dbCmd = GetCatalogForeignKeysCmd();
            _dbCmdCache.Add(Constants.CatalogGetForeignKeys, dbCmd);
        }



        /// <summary>
        /// Returns a structure containing metadata about columns used in an index
        /// </summary>
        /// <param name="columnName">The name of the column</param>
        /// <param name="IsAscending">Whether or not the column is sorted ascending (false = descending)</param>
        /// <returns>DbIndexColumnStructure</returns>
        public DbIndexColumn BuildIndexColumn(string columnName, bool IsAscending)
        {
            DbIndexColumn indexColumn = new DbIndexColumn();
            indexColumn.ColumnName = columnName;
            indexColumn.IsDescending = !IsAscending;
            return indexColumn;
        }

        /// <summary>
        /// Returns a structure containing metadata describing an index column that is sorted ascending
        /// </summary>
        /// <param name="columnName">Name of column</param>
        /// <returns>DbIndexColumnStructure for an ascending index</returns>
        public DbIndexColumn BuildIndexColumnAscending(string columnName)
        {
            return BuildIndexColumn(columnName, true);
        }

        /// <summary>
        /// Returns a structure containing metadata describing an index column that is sorted descending
        /// </summary>
        /// <param name="columnName">Name of column</param>
        /// <returns>DbIndexColumnStructure for an descending index</returns>
        public DbIndexColumn BuildIndexColumnDescending(string columnName)
        {
            return BuildIndexColumn(columnName, false);
        }

        /// <summary>
        /// Returns the DbCommand object to retrieve the database's catalog metadata about columns
        /// </summary>
        /// <returns>DbCommand object</returns>
        DbCommand GetCatalogColumnsCmd()
        {
            DbParameter paramSchemaName = _dbMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            DbParameter paramTableName = _dbMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            // each databaase has a different catalog so the query is different
            switch (_dbMgr.DbType)
            {
                case DatabaseMgr.DatabaseType.SqlServer:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.Tables
                                , DmlMgr.SelectColumnsAs(Constants.Name, Constants.TableName));

                        joinSelect.AddJoin(Constants.Sys, Constants.Schemas, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.Column(Constants.Tables, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.AddJoin(Constants.Sys, Constants.Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Sys, Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Sys, Constants.Tables, Constants.Object_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Id, Constants.OrdinalPosition)
                                    , joinSelect.ColumnsAs(Constants.Is_RowGuidCol, Constants.IsRowGuidCol)
                                    , joinSelect.ColumnsAs(Constants.Is_Computed, Constants.IsComputed)
                                    , joinSelect.ColumnsAs(Constants.Is_Identity, Constants.IsIdentity));

                        string tAlias = joinSelect.AddJoin(Constants.Information_Schema, Constants.Columns, DbTableJoinType.Inner,
                                (j) => j.Column(Constants.Information_Schema, Constants.Columns, Constants.Table_Schema)
                                    == j.Column(Constants.Sys, Constants.Schemas, Constants.Name)
                                && j.Column(Constants.Information_Schema, Constants.Columns, Constants.Table_Name)
                                    == j.Column(Constants.Sys, Constants.Tables, Constants.Name)
                                && j.Column(Constants.Information_Schema, Constants.Columns, Constants.Column_Name)
                                    == j.Column(Constants.Sys, Constants.Columns, Constants.Name)
                                    , joinSelect.ColumnsAs(Constants.Data_Type, Constants.DataType)
                                    , joinSelect.ColumnsAs(Constants.Column_Default, Constants.ColumnDefault)
                                    , joinSelect.ColumnsAs(Constants.Character_Mximum_Length, Constants.CharacterMaximumLength)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Precision, Constants.NumericPrecision)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Precision_Radix, Constants.NumericPrecisionRadix)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Scale, Constants.NumericScale)
                                    , joinSelect.ColumnsAs(Constants.DataTime_Precision, Constants.DataTimePrecision));

                        joinSelect.AddCaseColumn("0", Constants.IsNullable,
                                joinSelect.When(t => t.AliasedColumn(tAlias, Constants.Is_Nullable) == "yes", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas, Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.Tables, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Schemas
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Tables
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Columns
                                , BuildIndexColumnAscending(Constants.Column_Id)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.Oracle:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.All_Tab_Columns
                                , DmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.Data_Type, Constants.DataType)
                                , DmlMgr.SelectColumnsAs(Constants.Data_Default, Constants.ColumnDefault)
                                , DmlMgr.SelectColumnsAs(Constants.Char_Length, Constants.CharacterMaximumLength)
                                , DmlMgr.SelectColumnsAs(Constants.Data_Precision, Constants.NumericPrecision)
                                , new DbConstValue(DmlMgr.SelectColumnsAs("null", Constants.NumericPrecisionRadix))
                                , DmlMgr.SelectColumnsAs(Constants.Data_Scale, Constants.NumericScale)
                                , DmlMgr.SelectColumnsAs(Constants.Data_Length, Constants.DataTimePrecision)
                                , DmlMgr.SelectColumnsAs(Constants.Data_Length, Constants.Data_Length)
                                , DmlMgr.SelectColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                , DmlMgr.SelectColumnsAs(Constants.Column_Id, Constants.OrdinalPosition)
                                , new DbConstValue(DmlMgr.SelectColumnsAs("0", Constants.IsRowGuidCol))
                                , new DbConstValue(DmlMgr.SelectColumnsAs("0", Constants.IsComputed))
                                , new DbConstValue(DmlMgr.SelectColumnsAs("0", Constants.IsIdentity))
                                , new DbConstValue(DmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)));


                        joinSelect.AddCaseColumn("0", Constants.IsNullable,
                                joinSelect.When(t => t.Column(Constants.All_Tab_Columns, Constants.Nullable) == "Y", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Tab_Columns, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Tab_Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , BuildIndexColumnAscending(Constants.Column_Id)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.DB2:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.SysIbm
                                , Constants.Columns
                                , DmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)
                                , DmlMgr.SelectColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                , DmlMgr.SelectColumnsAs(Constants.Ordinal_Position, Constants.OrdinalPosition)
                                , DmlMgr.SelectColumnsAs(Constants.Column_Default, Constants.ColumnDefault)
                                , DmlMgr.SelectColumnsAs(Constants.Character_Mximum_Length
                                    , Constants.CharacterMaximumLength)
                                , DmlMgr.SelectColumnsAs(Constants.Numeric_Precision, Constants.NumericPrecision)
                                , DmlMgr.SelectColumnsAs(Constants.Numeric_Precision_Radix
                                    , Constants.NumericPrecisionRadix)
                                , DmlMgr.SelectColumnsAs(Constants.Numeric_Scale, Constants.NumericScale)
                                , DmlMgr.SelectColumnsAs(Constants.DataTime_Precision
                                    , Constants.DataTimePrecision)
                                , new DbConstValue(DmlMgr.SelectColumnsAs("0", Constants.IsRowGuidCol))
                                , new DbConstValue(DmlMgr.SelectColumnsAs("0", Constants.IsComputed)));

                        string tAlias = joinSelect.AddJoin(Constants.SysIbm, Constants.SQLColumns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SQLColumns, Constants.Column_Name)
                                    == j.Column(Constants.Columns, Constants.Column_Name)
                                    && j.Column(Constants.SQLColumns, Constants.Table_Name)
                                    == j.Column(Constants.Columns, Constants.Table_Name)
                                    && j.Column(Constants.SQLColumns, Constants.Table_Schem)
                                    == j.Column(Constants.Columns, Constants.Table_Schema)
                                        , joinSelect.ColumnsAs(Constants.Table_Schem, Constants.SchemaName)
                                        , joinSelect.ColumnsAs(Constants.Type_Name, Constants.DataType)
                                        , joinSelect.ColumnsAs(Constants.Nullable, Constants.IsNullable));

                        joinSelect.AddCaseColumn("0", Constants.IsIdentity,
                                joinSelect.When(t => t.AliasedColumn(tAlias, Constants.Pseudo_Column) == 2, "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysIbm, Constants.SQLColumns
                                    , Constants.Table_Schem)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysIbm, Constants.Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.SQLColumns
                                , BuildIndexColumnAscending(Constants.Table_Schem)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.Columns
                                , BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.Columns
                                , BuildIndexColumnAscending(Constants.Ordinal_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                                    string.Format(Global.Constants.FormatError_FunctionNotImpleted
                                    ,   _dbMgr.DbProvider.TypeName.ToString())));
            }
        }

        DbCommand GetCatalogPrimaryKeysCmd()
        {
            DbParameter paramSchemaName = _dbMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            DbParameter paramTableName = _dbMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            switch (_dbMgr.DbType)
            {
                case DatabaseMgr.DatabaseType.SqlServer:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.Indexes
                                , DmlMgr.SelectColumnsAs(Constants.Name, Constants.PrimaryKeyName));

                        joinSelect.AddJoin(Constants.Sys, Constants.Index_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Index_Columns, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Index_Id)
                                    == j.Column(Constants.Indexes, Constants.Index_Id)
                                    && j.Column(Constants.Indexes, Constants.Is_Primary_Key)
                                    == 1
                                    , joinSelect.ColumnsAs(Constants.Is_Descending_Key, Constants.IsDescend)
                                    , joinSelect.ColumnsAs(Constants.Key_Ordinal, Constants.Ordinal));

                        string c = joinSelect.AddJoin(Constants.Sys, Constants.SysColumns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SysColumns, Constants.Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Column_Id)
                                    == j.Column(Constants.SysColumns, Constants.ColId)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string t = joinSelect.AddJoin(Constants.Sys, Constants.Objects, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Objects, Constants.Type)
                                    == "U"
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.TableName));

                        string s = joinSelect.AddJoin(Constants.Sys, Constants.Schemas, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Schema_Id)
                                    == j.Column(Constants.Schemas, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                    , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys
                                    , Constants.Objects, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Schemas
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Objects
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Index_Columns
                                , BuildIndexColumnAscending(Constants.Key_Ordinal)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.Oracle:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.All_Indexes
                                , DmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.Index_Name, Constants.PrimaryKeyName));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Ind_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Name)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Position, Constants.Ordinal));

                        joinSelect.AddCaseColumn("0", Constants.IsDescend,
                                joinSelect.When(t => t.Column(Constants.All_Ind_Columns, Constants.Descend) == "DESC", "1"));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Constraints, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.Column(Constants.All_Constraints, Constants.Constraint_Type) == "P", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Indexes, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Ind_Columns, Constants.Table_Name)
                                    == paramTableName)
                                && j.Column(Constants.Sys, Constants.All_Constraints, Constants.Constraint_Type)
                                    == "P");

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Indexes
                                , BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Indexes
                                , BuildIndexColumnAscending(Constants.Index_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , BuildIndexColumnAscending(Constants.Column_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.DB2:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.SysCat
                                , Constants.Indexes
                                , DmlMgr.SelectColumnsAs(Constants.IndSchema, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.TabName, Constants.TableName)
                                , DmlMgr.SelectColumnsAs(Constants.IndName, Constants.PrimaryKeyName));

                        string tAlias = joinSelect.AddJoin(Constants.SysCat, Constants.IndexColUse, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Indexes, Constants.IndSchema)
                                    == j.Column(Constants.IndexColUse, Constants.IndSchema)
                                    && j.Column(Constants.Indexes, Constants.IndName)
                                    == j.Column(Constants.IndexColUse, Constants.IndName)
                                        , joinSelect.ColumnsAs(Constants.ColName, Constants.ColumnName)
                                        , joinSelect.ColumnsAs(Constants.ColSeq, Constants.Ordinal));

                        joinSelect.AddCaseColumn("1", Constants.IsDescend,
                                joinSelect.When(t => t.AliasedColumn(tAlias
                                        , Constants.ColOrder) == "A", "0"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.IndSchema)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.TabName)
                                    == paramTableName)
                                && j.Column(Constants.Indexes, Constants.UniqueRule) == "P");

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.IndSchema)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.TabName)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.IndName)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.IndexColUse
                                , BuildIndexColumnAscending(Constants.ColSeq)));
                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                                    string.Format("Unknown DatabaseType: {0}", _dbMgr.DatabaseTypeName.ToString())));
            }
        }

        /// <summary>
        /// Returns the DbCommand object to retrieve the database's catalog metadata about indexes
        /// </summary>
        /// <returns>DbCommand object</returns>
        DbCommand GetCatalogIndexesCmd()
        {
            DbParameter paramSchemaName = _dbMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            DbParameter paramTableName = _dbMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            switch (_dbMgr.DbType)
            {
                case DatabaseMgr.DatabaseType.SqlServer:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.Indexes
                                , DmlMgr.SelectColumnsAs(Constants.Name, Constants.IndexName)
                                , DmlMgr.SelectColumnsAs(Constants.Is_Unique, Constants.IsUnique)
                                , DmlMgr.SelectColumnsAs(Constants.Is_Primary_Key, Constants.IsPrimaryKey)
                                , DmlMgr.SelectColumnsAs(Constants.Type_Desc, Constants.TypeDescription)
                                , new DbConstValue(DmlMgr.SelectColumnsAs("null", Constants.ColumnFunction)));

                        joinSelect.AddJoin(Constants.Sys, Constants.Index_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Index_Columns, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Index_Id)
                                    == j.Column(Constants.Indexes, Constants.Index_Id)
                                    , joinSelect.ColumnsAs(Constants.Is_Descending_Key, Constants.IsDescend)
                                    , joinSelect.ColumnsAs(Constants.Key_Ordinal, Constants.Ordinal));

                        string c = joinSelect.AddJoin(Constants.Sys, Constants.SysColumns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SysColumns, Constants.Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Column_Id)
                                    == j.Column(Constants.SysColumns, Constants.ColId)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string t = joinSelect.AddJoin(Constants.Sys, Constants.Objects, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Objects, Constants.Type)
                                    == "U"
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.TableName));

                        string s = joinSelect.AddJoin(Constants.Sys, Constants.Schemas, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Schema_Id)
                                    == j.Column(Constants.Schemas, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                    , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys
                                    , Constants.Objects, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Schemas
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Objects
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Sys
                                , Constants.Index_Columns
                                , BuildIndexColumnAscending(Constants.Key_Ordinal)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.Oracle:
                    {
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.Sys
                                , Constants.All_Indexes
                                , DmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.Index_Name, Constants.IndexName));

                        joinSelect.AddCaseColumn("0", Constants.IsUnique,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.Uniqueness) == "UNIQUE", "1"));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Ind_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Name)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Position, Constants.Ordinal));

                        joinSelect.AddCaseColumn("0", Constants.IsDescend,
                                joinSelect.When(t => t.Column(Constants.All_Ind_Columns, Constants.Descend) == "DESC", "1"));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Ind_Expressions, DbTableJoinType.LeftOuter
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Index_Name)
                                    && j.Column(Constants.All_Ind_Columns, Constants.Column_Position)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Column_Position)
                                    , joinSelect.ColumnsAs(Constants.Column_Expression, Constants.ColumnFunction));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Constraints, DbTableJoinType.LeftOuter
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.Column(Constants.All_Constraints, Constants.Constraint_Type) == "P", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Indexes, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Ind_Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Indexes
                                , BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Indexes
                                , BuildIndexColumnAscending(Constants.Index_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , BuildIndexColumnAscending(Constants.Column_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.DB2:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.SysCat
                                , Constants.Indexes
                                , DmlMgr.SelectColumnsAs(Constants.IndSchema, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.TabName, Constants.TableName)
                                , DmlMgr.SelectColumnsAs(Constants.IndName, Constants.IndexName)
                                , DmlMgr.SelectColumnsAs(Constants.IndexType, Constants.TypeDescription)
                                , new DbConstValue(DmlMgr.SelectColumnsAs("null", Constants.ColumnFunction)));

                        joinSelect.AddCaseColumn("0", Constants.IsUnique,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "P", "1"),
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "U", "1"));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "P", "1"));

                        string tAlias = joinSelect.AddJoin(Constants.SysCat, Constants.IndexColUse, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Indexes, Constants.IndSchema)
                                    == j.Column(Constants.IndexColUse, Constants.IndSchema)
                                    && j.Column(Constants.Indexes, Constants.IndName)
                                    == j.Column(Constants.IndexColUse, Constants.IndName)
                                        , joinSelect.ColumnsAs(Constants.ColName, Constants.ColumnName)
                                        , joinSelect.ColumnsAs(Constants.ColSeq, Constants.Ordinal));

                        joinSelect.AddCaseColumn("1", Constants.IsDescend,
                                joinSelect.When(t => t.AliasedColumn(tAlias
                                        , Constants.ColOrder) == "A", "0"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.IndSchema)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.TabName)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.IndSchema)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.TabName)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.Indexes
                                , BuildIndexColumnAscending(Constants.IndName)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.SysCat
                                , Constants.IndexColUse
                                , BuildIndexColumnAscending(Constants.ColSeq)));
                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                            string.Format("Unknown DbType: {0}", _dbMgr.DbType.ToString())));
            }
        }

        /// <summary>
        /// Returns the DbCommand object to retrieve the database's catalog metadata about Foreign Keys
        /// </summary>
        /// <returns>DbCommand object</returns>
        DbCommand GetCatalogForeignKeysCmd()
        {
            DbParameter paramSchemaName = _dbMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            DbParameter paramTableName = _dbMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, DBNull.Value);

            switch (_dbMgr.DbType)
            {
                case DatabaseMgr.DatabaseType.SqlServer:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                    , Constants.Sys
                                    , Constants.Tables
                                    , DmlMgr.SelectColumnsAs(Constants.Name, Constants.TableName));

                        joinSelect.AddJoin(Constants.Sys, Constants.Schemas, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.Column(Constants.Tables, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.AddJoin(Constants.Sys, Constants.Foreign_Keys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Keys, Constants.Parent_Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    , DmlMgr.SelectColumnsAs(Constants.Name, Constants.ForeignKey));

                        string fkc = joinSelect.AddJoin(Constants.Sys, Constants.Foreign_Key_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Key_Columns, Constants.Constraint_Object_Id)
                                    == j.Column(Constants.Foreign_Keys, Constants.Object_Id));

                        joinSelect.AddJoin(Constants.Sys, Constants.Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    && j.Column(Constants.Foreign_Key_Columns, Constants.Parent_Column_Id)
                                    == j.Column(Constants.Columns, Constants.Column_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string refT = joinSelect.AddJoin(Constants.Sys, Constants.Tables, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Keys, Constants.Referenced_Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.RefTable));

                        joinSelect.AddJoin(Constants.Sys, Constants.Schemas, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.AliasedColumn(refT, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.RefSchema));

                        joinSelect.AddJoin(Constants.Sys, Constants.Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Foreign_Keys, Constants.Referenced_Object_Id)
                                    && j.AliasedColumn(fkc, Constants.Referenced_Column_Id)
                                    == j.Column(Constants.Columns, Constants.Column_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        joinSelect.AddJoin(Constants.Information_Schema, Constants.Key_Column_Usage, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Key_Column_Usage, Constants.Table_Schema)
                                    == j.Column(Constants.Schemas, Constants.Name)
                                    && j.Column(Constants.Key_Column_Usage, Constants.Column_Name)
                                    == j.Column(Constants.Columns, Constants.Name)
                                    && j.Column(Constants.Key_Column_Usage, Constants.Table_Name)
                                    == j.Column(Constants.Tables, Constants.Name)
                                    , joinSelect.ColumnsAs(Constants.Ordinal_Position, Constants.Ordinal));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.Tables
                                , Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Schemas
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Tables
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.Foreign_Keys
                                , BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(
                                Constants.Information_Schema
                                , Constants.Key_Column_Usage
                                , BuildIndexColumnAscending(Constants.Ordinal_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.Oracle:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                    , Constants.Sys
                                    , Constants.All_Constraints
                                    , DmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                    , DmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , DmlMgr.SelectColumnsAs(Constants.Constraint_Name, Constants.ForeignKey));

                        string cc = joinSelect.AddJoin(Constants.Sys, Constants.All_Cons_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Cons_Columns, Constants.Constraint_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Table_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Table_Name)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Position, Constants.Ordinal));

                        joinSelect.AddJoin(Constants.Sys, Constants.All_Cons_Columns, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Cons_Columns, Constants.Constraint_Name)
                                    == j.Column(Constants.All_Constraints, Constants.R_Constraint_Name)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.R_Owner)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Position)
                                    == j.AliasedColumn(cc, Constants.Position)
                                    , joinSelect.ColumnsAs(Constants.Owner, Constants.RefSchema)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.RefTable)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.RefColumn));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Constraints
                                , Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Constraints
                                , Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Constraints
                                , BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Constraints
                                , BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Constraints
                                , BuildIndexColumnAscending(Constants.Constraint_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.Sys
                                , Constants.All_Constraints
                                , cc
                                , BuildIndexColumnAscending(Constants.Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DatabaseMgr.DatabaseType.DB2:
                    {
                        // base table
                        DmlMgr joinSelect = new DmlMgr(_dbMgr
                                , Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , DmlMgr.SelectColumnsAs(Constants.FKTable_Schem, Constants.SchemaName)
                                , DmlMgr.SelectColumnsAs(Constants.FKTable_Name, Constants.TableName)
                                , DmlMgr.SelectColumnsAs(Constants.FK_Name, Constants.ForeignKey)
                                , DmlMgr.SelectColumnsAs(Constants.FKColumn_Name, Constants.ColumnName)
                                , DmlMgr.SelectColumnsAs(Constants.PKTable_Schem, Constants.RefSchema)
                                , DmlMgr.SelectColumnsAs(Constants.PKTable_Name, Constants.RefTable)
                                , DmlMgr.SelectColumnsAs(Constants.PKColumn_Name, Constants.RefColumn)
                                , DmlMgr.SelectColumnsAs(Constants.Key_Seq, Constants.Ordinal));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysIbm, Constants.SQLForeignKeys
                                , Constants.FKTable_Schem)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysIbm, Constants.SQLForeignKeys
                                , Constants.FKTable_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , BuildIndexColumnAscending(Constants.FKTable_Schem)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , BuildIndexColumnAscending(Constants.FKTable_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , BuildIndexColumnAscending(Constants.FK_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumn>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , BuildIndexColumnAscending(Constants.Key_Seq)));

                        // build the dbCommand
                        DbCommand dbCmd = _dbMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                            string.Format("Unknown DbType: {0}", _dbMgr.DbType.ToString())));
            }
        }

        internal DbColumn GetDbColumn(string schemaName, string tableName, string columnName)
        {
            if (string.IsNullOrEmpty(schemaName))
                throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                              , Constants.SchemaName)));

            if (string.IsNullOrEmpty(tableName))
                throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                            , Constants.TableName)));

            if (string.IsNullOrEmpty(columnName))
                throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                            , Constants.ColumnName)));

            // make sure the Table Cache is loaded
            GetDbTable(schemaName, tableName);
            string fullyQualifiedColumnName = schemaName.ToUpper() + "." + tableName.ToUpper()
                    + "." + columnName.ToUpper();

            // Now lookup the column in the cache
            if (!_columnCache.Exists(fullyQualifiedColumnName))
                // if the table cache was loaded, then the column was not found
                throw new ExceptionMgr(this.ToString(), new ArgumentOutOfRangeException(
                               string.Format(Global.Constants.FormatError_InvalidParameterValue
                                    , Constants.ColumnName, fullyQualifiedColumnName
                                    , "Column not found in database catalog")));
            // otherwise return it.
            return _columnCache.Get(fullyQualifiedColumnName);
        }


        internal DbTable GetDbTable(string schemaName, string tableName)
        {
            if (string.IsNullOrEmpty(schemaName))
                throw new ExceptionMgr(this.ToString(), new ArgumentNullException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                            , Constants.SchemaName)));

            if (string.IsNullOrEmpty(tableName))
                throw new ExceptionMgr(this.ToString(), new ArgumentNullException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                            , Constants.TableName)));

            string fullyQualifiedTableName = schemaName + "." + tableName;
            return GetDbTable(fullyQualifiedTableName);
        }

        internal DbTable GetDbTable(string fullyQualifiedTableName)
        {
            if (string.IsNullOrEmpty(fullyQualifiedTableName))
                throw new ExceptionMgr(this.ToString(), new ArgumentNullException(
                              string.Format(Global.Constants.FormatError_NullOrEmptyParameter
                            , "fullyQualifiedTableName")));

            DbTable cacheRef = _tableCache.GetOrAdd(fullyQualifiedTableName,
                () => GetTableMetaData(fullyQualifiedTableName));
            return new DbTable(cacheRef);
        }



        /// <summary>
        /// Creates the table meta data structure for a given fully qualified table name.
        /// (Schema and table Name)
        /// </summary>
        /// <param name="fullyQualifiedTableName"></param>
        DbTable GetTableMetaData(string fullyQualifiedTableName)
        {
            DataSet catalogDataSet = GetCatalogData(fullyQualifiedTableName.ToUpper());
            // see if table was found
            if (catalogDataSet.Tables[Database.Constants.Columns].Rows.Count == 0)
                throw new ExceptionMgr(this.ToString(), new ArgumentNullException(
                              string.Format(Global.Constants.FormatError_InvalidParameterValue
                                    , Database.Constants.TableName, fullyQualifiedTableName)));

            // otherwise populate the cache
            return CreateTableMetaData(catalogDataSet.Tables[Constants.PrimaryKeys]
                        , catalogDataSet.Tables[Constants.Columns]
                        , catalogDataSet.Tables[Constants.Indexes]
                        , catalogDataSet.Tables[Constants.ForeignKeys]);
        }

        /// <summary>
        /// Get the Catalog Data from the Database by fully qualified table name
        /// (Schema and Table Name)
        /// </summary>
        /// <param name="fullyQualifiedTableName"></param>
        /// <returns>A dataset of catalog data</returns>
        DataSet GetCatalogData(string fullyQualifiedTableName)
        {
            string[] nameParts = fullyQualifiedTableName.Split(new char[] { '.' });
            string schemaName = nameParts[0];
            string tableName = nameParts[1];
            return GetCatalogData(schemaName, tableName);
        }


        /// <summary>
        /// Returns the Database Catalog MetaData for the given table and schema
        /// </summary>
        /// <param name="schemaName">Schema that table belongs to</param>
        /// <param name="tableName">Table name to retrieve meta data</param>
        /// <returns>Dataset of meta data (columns, indexes, primaryKey, foreignKey)</returns>
        DataSet GetCatalogData(string schemaName, string tableName)
        {
            string schemaNameUpper = !string.IsNullOrEmpty(schemaName) ? schemaName.ToUpper() : null;
            string tableNameUpper = !string.IsNullOrEmpty(tableName) ? tableName.ToUpper() : null;
            List<string> tableNames = new List<string>();
            DbCommandMgr dbCmdMgr = new DbCommandMgr(_dbMgr);
            DbCommand cmdPrimaryKey = _dbMgr.DbProvider.CloneDbCommand(_dbCmdCache.Get(Constants.CatalogGetPrimaryKeys));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdPrimaryKey);
            tableNames.Add(Constants.PrimaryKeys);

            DbCommand cmdIndex = _dbMgr.DbProvider.CloneDbCommand(_dbCmdCache.Get(Constants.CatalogGetIndexes));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdIndex);
            tableNames.Add(Constants.Indexes);

            DbCommand cmdForeignKeys = _dbMgr.DbProvider.CloneDbCommand(_dbCmdCache.Get(Constants.CatalogGetForeignKeys));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdForeignKeys);
            tableNames.Add(Constants.ForeignKeys);

            DbCommand cmdColumns = _dbMgr.DbProvider.CloneDbCommand(_dbCmdCache.Get(Constants.CatalogGetColumns));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdColumns);
            tableNames.Add(Constants.Columns);

            return dbCmdMgr.ExecuteDataSet(tableNames);
        }

        /// <summary>
        /// Returns the combined meta data of a table given the metadata of its different objects
        /// </summary>
        /// <param name="primaryKey">PrimaryKey meta data</param>
        /// <param name="columns">Column meta data</param>
        /// <param name="indexes">Index meta data</param>
        /// <param name="foreignKeys">ForeignKey meta data</param>
        /// <returns>Structure of table meta data</returns>
        DbTable CreateTableMetaData(DataTable primaryKey, DataTable columns, DataTable indexes, DataTable foreignKeys)
        {
            DbTable table = PopulateColumnCache(columns);
            table.PrimaryKeyColumns = GetPrimaryKeyColumns(table.SchemaName, table.TableName, primaryKey);
            table.PrimaryKey = GetPrimaryKey(table.SchemaName, table.TableName, primaryKey);
            table.Indexes = GetIndexes(table.SchemaName, table.TableName, table.Columns, indexes);
            table.ForeignKeys = GetForeignKeys(table.SchemaName, table.TableName, foreignKeys);
            return table;
        }

        /// <summary>
        /// Returns the index meta data for the given schema and table names and column and index data
        /// </summary>
        /// <param name="tableSchema">Schema index belongs to</param>
        /// <param name="tableName">Table index belongs to</param>
        /// <param name="tableColumns">the tables columns</param>
        /// <param name="indexes">DataTable of indexes for the table</param>
        /// <returns>Dictionary of index name and index meta data</returns>
        Dictionary<string, DbIndex> GetIndexes(string tableSchema
                , string tableName
                , Dictionary<string, Int16> tableColumns
                , DataTable indexes)
        {
            DataRow[] tableIndexes = indexes.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            Dictionary<string, DbIndex> tableIndexCollection
                    = new Dictionary<string, DbIndex>(StringComparer.CurrentCultureIgnoreCase);

            DbIndex index = new DbIndex();
            index.Columns = new SortedDictionary<short, DbIndexColumn>();
            for (byte i = 0; i < tableIndexes.Length; i++)
            {
                if (string.IsNullOrEmpty(index.IndexName)
                    || tableIndexes[i][Constants.IndexName].ToString().ToUpper() != index.IndexName.ToUpper())
                {
                    // we are on a new index
                    // save the previous one if there was one
                    if (!string.IsNullOrEmpty(index.IndexName))
                    {
                        tableIndexCollection.Add(index.IndexName, index);
                        index = new DbIndex();
                        index.Columns = new SortedDictionary<short, DbIndexColumn>();
                    }

                    index.IndexName = tableIndexes[i][Constants.IndexName].ToString();
                    index.SchemaName = tableSchema;
                    index.TableName = tableName;
                    index.IsPrimaryKey = Convert.ToBoolean(tableIndexes[i][Constants.IsPrimaryKey]);
                    index.IsUnique = Convert.ToBoolean(tableIndexes[i][Constants.IsUnique]);
                }
                DbIndexColumn indexColumn = new DbIndexColumn();
                indexColumn.ColumnFunction = tableIndexes[i][Constants.ColumnFunction].ToString();
                if (string.IsNullOrEmpty(indexColumn.ColumnFunction))
                    indexColumn.ColumnName = tableIndexes[i][Constants.ColumnName].ToString();
                else // we must parse the column name from the function (Oracle - functional based index)
                {
                    foreach (string column in tableColumns.Keys)
                        if (indexColumn.ColumnFunction.Contains(column))
                        {
                            indexColumn.ColumnName = column;
                            break;
                        }
                }
                indexColumn.IsDescending = Convert.ToBoolean(tableIndexes[i][Constants.IsDescend]);
                index.Columns.Add(Convert.ToInt16(tableIndexes[i][Constants.Ordinal]), indexColumn);
            }
            if (!string.IsNullOrEmpty(index.IndexName))
                tableIndexCollection.Add(index.IndexName, index);
            return tableIndexCollection;
        }


        /// <summary>
        /// Returns the foreign key meta data for the given schema and table names and foreign key data
        /// </summary>
        /// <param name="tableSchema">Schema index belongs to</param>
        /// <param name="tableName">Table index belongs to</param>
        /// <param name="foreignKeys">Datatable of foreign key meta data</param>
        /// <returns>Dictionary of foreign key name and foreign key meta data</returns>
        Dictionary<string, DbForeignKey> GetForeignKeys(string tableSchema
                , string tableName
                , DataTable foreignKeys)
        {
            DataRow[] tableForeignKeys = foreignKeys.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));

            Dictionary<string, DbForeignKey> tableFKeyCollection
                    = new Dictionary<string, DbForeignKey>(StringComparer.CurrentCultureIgnoreCase);

            DbForeignKey foreignKey = new DbForeignKey();
            foreignKey.KeyColumns = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
            foreignKey.KeyOrder = new SortedDictionary<Int16, string>();
            for (byte i = 0; i < tableForeignKeys.Length; i++)
            {
                if (string.IsNullOrEmpty(foreignKey.ForeignKeyName)
                    || tableForeignKeys[i][Constants.ForeignKey].ToString().ToUpper() != foreignKey.ForeignKeyName.ToUpper())
                {
                    // we are on a new index
                    // save the previous one if there was one
                    if (!string.IsNullOrEmpty(foreignKey.ForeignKeyName))
                    {
                        tableFKeyCollection.Add(foreignKey.ForeignKeyName, foreignKey);
                        foreignKey = new DbForeignKey();
                        foreignKey.KeyColumns = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
                        foreignKey.KeyOrder = new SortedDictionary<Int16, string>();
                    }
                    foreignKey.ForeignKeyName = tableForeignKeys[i][Constants.ForeignKey].ToString();
                    foreignKey.SchemaName = tableForeignKeys[i][Constants.RefSchema].ToString();
                    foreignKey.TableName = tableForeignKeys[i][Constants.RefTable].ToString();
                }

                foreignKey.KeyColumns.Add(tableForeignKeys[i][Constants.ColumnName].ToString(), tableForeignKeys[i][Constants.RefTable].ToString());
                foreignKey.KeyOrder.Add(Convert.ToInt16(tableForeignKeys[i][Constants.Ordinal]), tableForeignKeys[i][Constants.ColumnName].ToString());
            }
            if (!string.IsNullOrEmpty(foreignKey.ForeignKeyName))
                tableFKeyCollection.Add(foreignKey.ForeignKeyName, foreignKey);
            return tableFKeyCollection;
        }

        /// <summary>
        /// Returns the primary key columns for the given schema and table names and primary key data
        /// </summary>
        /// <param name="tableSchema">Schema index belongs to</param>
        /// <param name="tableName">Table index belongs to</param>
        /// <param name="primaryKey">DataTable of primary key for the table</param>
        /// <returns>Dictionary of column name and index key number</returns>
        Dictionary<string, byte> GetPrimaryKeyColumns(string tableSchema, string tableName, DataTable primaryKey)
        {
            DataRow[] primaryKeyCols = primaryKey.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            Dictionary<string, byte> primaryKeyColumnNames
                    = new Dictionary<string, byte>(StringComparer.CurrentCultureIgnoreCase);
            for (byte i = 0; i < primaryKeyCols.Length; i++)
                primaryKeyColumnNames.Add(primaryKeyCols[i][Constants.ColumnName].ToString()
                        , i);
            return primaryKeyColumnNames;
        }

        /// <summary>
        /// Returns the ordered columns of the given primary key
        /// </summary>
        /// <param name="tableSchema">Schema index belongs to</param>
        /// <param name="tableName">Table index belongs to</param>
        /// <param name="primaryKey">DataTable of primary key for the table</param>
        /// <returns>SortedDictionary of the primary key columns</returns>
        SortedDictionary<byte, string> GetPrimaryKey(string tableSchema, string tableName, DataTable primaryKey)
        {
            DataRow[] primaryKeyCols = primaryKey.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            SortedDictionary<byte, string> primaryKeyColumnNames = new SortedDictionary<byte, string>();
            for (byte i = 0; i < primaryKeyCols.Length; i++)
                primaryKeyColumnNames.Add(i, primaryKeyCols[i][Constants.ColumnName].ToString());
            return primaryKeyColumnNames;
        }

        /// <summary>
        /// Returns table meta data structure for the given DataTable of column meta data.
        /// </summary>
        /// <param name="columns">DataTable of column meta data</param>
        /// <returns>Table metadata structure</returns>
        /// <exception cref="ExceptionEvent">Any exception during the processing of the cache.  
        /// Message will include Schema and Table Name</exception>
        DbTable PopulateColumnCache(DataTable columns)
        {
            DbCommandMgr dbCmdMgr = new DbCommandMgr(_dbMgr);
            DbTable table = new DbTable();
            table.SchemaName = columns.Rows[0][TableAttributes.SchemaName.ToString()].ToString();
            table.TableName = columns.Rows[0][TableAttributes.TableName.ToString()].ToString();
            table.Columns = new Dictionary<string, Int16>(StringComparer.CurrentCultureIgnoreCase);
            table.Row = new SortedDictionary<Int16, string>();
            foreach (DataRow columnRow in columns.Rows)
            {
                try
                {
                    DbColumn column = new DbColumn();
                    column.SchemaName = columnRow[ColumnAttributes.SchemaName.ToString()].ToString();
                    column.TableName = columnRow[ColumnAttributes.TableName.ToString()].ToString();
                    column.ColumnName = columnRow[ColumnAttributes.ColumnName.ToString()].ToString();
                    column.Ordinal = Convert.ToInt16(columnRow[ColumnAttributes.OrdinalPosition.ToString()]);

                    table.Columns.Add(column.ColumnName, column.Ordinal);
                    column.DataTypeNativeDb = columnRow[ColumnAttributes.DataType.ToString()].ToString();

                    if (columnRow[ColumnAttributes.NumericPrecision.ToString()] != DBNull.Value)
                        column.Precision = Convert.ToInt16(columnRow[ColumnAttributes.NumericPrecision.ToString()]);
                    if (columnRow[ColumnAttributes.NumericPrecisionRadix.ToString()] != DBNull.Value)
                        column.Radix = Convert.ToInt16(columnRow[ColumnAttributes.NumericPrecisionRadix.ToString()]);
                    if (columnRow[ColumnAttributes.NumericScale.ToString()] != DBNull.Value)
                        column.Scale = Convert.ToInt16(columnRow[ColumnAttributes.NumericScale.ToString()]);

                    if (_dbMgr.DbType == DatabaseMgr.DatabaseType.Oracle
                        && column.DataTypeNativeDb.ToLower() == "number")
                    {
                        column.DataTypeDotNet = _dbMgr.DbProvider.GetDotNetDataTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb
                                                                            , column.Precision
                                                                            , column.Scale);
                        column.DataTypeGenericDb = _dbMgr.DbProvider.GetGenericDbTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb
                                                                            , column.Precision
                                                                            , column.Scale);
                        column.DataTypeDataColumn = "System.Decimal";
                    }
                    else
                    {
                        column.DataTypeDotNet = column.DataTypeDataColumn = _dbMgr.DbProvider.GetDotNetDataTypeFromNativeDataType(
                                                                                column.DataTypeNativeDb);
                        column.DataTypeGenericDb = _dbMgr.DbProvider.GetGenericDbTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb);
                    }

                    column.IsNullable = Convert.ToBoolean(columnRow[ColumnAttributes.IsNullable.ToString()]);
                    column.IsAutoGenerated = Convert.ToBoolean(columnRow[ColumnAttributes.IsIdentity.ToString()]);
                    column.HasDefault = columnRow[ColumnAttributes.ColumnDefault.ToString()] == DBNull.Value ? false : true;
                    if (columnRow[ColumnAttributes.CharacterMaximumLength.ToString()] != DBNull.Value)
                        column.MaxLength = Convert.ToInt32(columnRow[ColumnAttributes.CharacterMaximumLength.ToString()]);

                    table.Row.Add(column.Ordinal, column.ColumnName);
                    // add to column cache
                    _columnCache.Set(column.FullyQualifiedName, column);
                }
                catch (Exception exc)
                {
                    string msg = string.Format("Schema: {0}; Table: {1}; Column:{2}"
                            , table.SchemaName
                            , table.TableName
                            , columnRow[ColumnAttributes.ColumnName.ToString()]);
                    throw new ExceptionMgr(this.ToString(), new ApplicationException(
                                    string.Format(Global.Constants.FormatError_UnhandledException
                                        , msg, exc)));
                }
            }
            return table;
        }
    }
}
